/*
	Copyright (c) 2013 The Demigods Team
	
	Demigods License v1
	
	This plugin is provided "as is" and without any warranty.  Any express or
	implied warranties, including, but not limited to, the implied warranties
	of merchantability and fitness for a particular purpose are disclaimed.
	In no event shall the authors be liable to any party for any direct,
	indirect, incidental, special, exemplary, or consequential damages arising
	in any way out of the use or misuse of this plugin.
	
	Definitions
	
	 1. This Plugin is defined as all of the files within any archive
	    file or any group of files released in conjunction by the Demigods Team,
	    the Demigods Team, or a derived or modified work based on such files.
	
	 2. A Modification, or a Mod, is defined as this Plugin or a derivative of
	    it with one or more Modification applied to it, or as any program that
	    depends on this Plugin.
	
	 3. Distribution is defined as allowing one or more other people to in
	    any way download or receive a copy of this Plugin, a Modified
	    Plugin, or a derivative of this Plugin.
	
	 4. The Software is defined as an installed copy of this Plugin, a
	    Modified Plugin, or a derivative of this Plugin.
	
	 5. The Demigods Team is defined as Alex Bennett and Alexander Chauncey
	    of http://www.censoredsoftware.com/.
	
	Agreement
	
	 1. Permission is hereby granted to use, copy, modify and/or
	    distribute this Plugin, provided that:
	
	    a. All copyright notices within source files and as generated by
	       the Software as output are retained, unchanged.
	
	    b. Any Distribution of this Plugin, whether as a Modified Plugin
	       or not, includes this license and is released under the terms
	       of this Agreement. This clause is not dependant upon any
	       measure of changes made to this Plugin.
	
	    c. This Plugin, Modified Plugins, and derivative works may not
	       be sold or released under any paid license without explicit 
	       permission from the Demigods Team. Copying fees for the 
	       transport of this Plugin, support fees for installation or
	       other services, and hosting fees for hosting the Software may,
	       however, be imposed.
	
	    d. Any Distribution of this Plugin, whether as a Modified
	       Plugin or not, requires express written consent from the
	       Demigods Team.
	
	 2. You may make Modifications to this Plugin or a derivative of it,
	    and distribute your Modifications in a form that is separate from
	    the Plugin. The following restrictions apply to this type of
	    Modification:
	
	    a. A Modification must not alter or remove any copyright notices
	       in the Software or Plugin, generated or otherwise.
	
	    b. When a Modification to the Plugin is released, a
	       non-exclusive royalty-free right is granted to the Demigods Team
	       to distribute the Modification in future versions of the
	       Plugin provided such versions remain available under the
	       terms of this Agreement in addition to any other license(s) of
	       the initial developer.
	
	    c. Any Distribution of a Modified Plugin or derivative requires
	       express written consent from the Demigods Team.
	
	 3. Permission is hereby also granted to distribute programs which
	    depend on this Plugin, provided that you do not distribute any
	    Modified Plugin without express written consent.
	
	 4. The Demigods Team reserves the right to change the terms of this
	    Agreement at any time, although those changes are not retroactive
	    to past releases, unless redefining the Demigods Team. Failure to
	    receive notification of a change does not make those changes invalid.
	    A current copy of this Agreement can be found included with the Plugin.
	
	 5. This Agreement will terminate automatically if you fail to comply
	    with the limitations described herein. Upon termination, you must
	    destroy all copies of this Plugin, the Software, and any
	    derivatives within 48 hours.
 */

package com.censoredsoftware.Demigods.API;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;

import org.bukkit.OfflinePlayer;

import com.censoredsoftware.Demigods.Demigods;
import com.censoredsoftware.Demigods.Libraries.Objects.PlayerCharacter;
import com.censoredsoftware.Demigods.Libraries.Objects.SerialLocation;

public class DataAPI
{
	private static final Demigods API = Demigods.INSTANCE;

	// Define HashMaps
	private static final HashMap<String, HashMap<String, Object>> pluginData = new HashMap<String, HashMap<String, Object>>();
	private static final HashMap<Object, HashMap<String, HashMap<String, Object>>> timedData = new HashMap<Object, HashMap<String, HashMap<String, Object>>>();
	private static final HashMap<String, HashMap<String, Object>> playerData = new HashMap<String, HashMap<String, Object>>();
	private static final HashMap<Integer, HashMap<String, Object>> charData = new HashMap<Integer, HashMap<String, Object>>();
	private static final HashMap<Integer, HashMap<String, Object>> battleData = new HashMap<Integer, HashMap<String, Object>>();
	private static final HashMap<Integer, HashMap<String, Object>> taskData = new HashMap<Integer, HashMap<String, Object>>();
	private static final HashMap<String, HashMap<Integer, Object>> blockData = new HashMap<String, HashMap<Integer, Object>>();

	/*
	 * ---------------------------------------------------
	 * Begin Plugin Data Methods
	 * ---------------------------------------------------
	 * 
	 * savePluginData() : Saves (String)dataID to pluginData HashMap.
	 */
	public boolean savePluginData(String dataID, String dataKey, Object dataValue)
	{
		dataKey = dataKey.toLowerCase();

		if(pluginData.containsKey(dataID))
		{
			pluginData.get(dataID).put(dataKey, dataValue);
			return true;
		}
		else
		{
			pluginData.put(dataID, new HashMap<String, Object>());
			pluginData.get(dataID).put(dataKey, dataValue);
			return true;
		}
	}

	/*
	 * removePluginData() : Removes (String)dataID from pluginData HashMap.
	 */
	public boolean removePluginData(String dataID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		if(pluginData.containsKey(dataID))
		{
			pluginData.get(dataID).remove(dataKey);
			return true;
		}
		else return false;
	}

	/*
	 * hasPluginData() : Returns true/false according to if (String)dataKey exists for (String)dataID.
	 */
	public boolean hasPluginData(String dataID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		return pluginData.containsKey(dataID) && pluginData.get(dataID).get(dataKey) != null;
	}

	/*
	 * getPluginData() : Returns (Object)dataValue for (int)dataID's (String)dataKey.
	 */
	public Object getPluginData(String dataID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		if(pluginData.containsKey(dataID))
		{
			if(pluginData.get(dataID) != null) return pluginData.get(dataID).get(dataKey);
			else return null;
		}
		else return null;
	}

	/*
	 * getAllPluginData() : Returns all pluginData.
	 */
	public static HashMap<String, HashMap<String, Object>> getAllPluginData()
	{
		return pluginData;
	}

	/*
	 * ---------------------------------------------------
	 * Begin Block Data Methods
	 * ---------------------------------------------------
	 * 
	 * saveBlockData() : Saves (int)blockID to blockData HashMap.
	 */
	public boolean saveBlockData(String blockType, int blockID, Object blockObject)
	{
		if(blockData.containsKey(blockType))
		{
			blockData.get(blockType).put(blockID, blockObject);
			return true;
		}
		else
		{
			blockData.put(blockType, new HashMap<Integer, Object>());
			blockData.get(blockType).put(blockID, blockObject);
			return true;
		}
	}

	/*
	 * hasBlockData() : Returns true/false according to if (String)dataKey exists for (String)dataID.
	 */
	public boolean hasBlockData(String blockType)
	{
		return blockData.containsKey(blockType);
	}

	public boolean hasBlockData(String blockType, int blockID)
	{
		return blockData.containsKey(blockType) && pluginData.get(blockType).containsKey(blockID);
	}

	/*
	 * removeBlockData() : Returns true/false according to if (String)dataKey exists for (String)dataID.
	 */
	public void removeBlockData(String blockType, int blockID)
	{
		if(blockData.containsKey(blockType)) blockData.get(blockType).remove(blockID);
	}

	/*
	 * getAllBlockData() : Returns all block data.
	 */
	public static HashMap<String, HashMap<Integer, Object>> getAllBlockData()
	{
		return blockData;
	}

	/*
	 * ---------------------------------------------------
	 * Begin Player Data Methods
	 * ---------------------------------------------------
	 * 
	 * savePlayerData() : Saves (String)dataKey to (int)playerID HashMap.
	 */
	public boolean savePlayerData(OfflinePlayer player, String dataKey, Object dataValue)
	{
		String playerName = player.getName();
		dataKey = dataKey.toLowerCase();

		if(playerData.containsKey(playerName))
		{
			playerData.get(playerName).put(dataKey, dataValue);
			return true;
		}
		else return false;
	}

	/*
	 * removePlayerData() : Removes (String)dataKey from (int)playerID's HashMap.
	 */
	public boolean removePlayerData(OfflinePlayer player, String dataKey)
	{
		String playerName = player.getName();
		dataKey = dataKey.toLowerCase();

		if(playerData.containsKey(playerName))
		{
			playerData.get(playerName).remove(dataKey);
			return true;
		}
		else return false;
	}

	/*
	 * hasPlayerData() : Returns true/false according to if (String)dataKey exists for (int)playerID.
	 */
	public boolean hasPlayerData(OfflinePlayer player, String dataKey)
	{
		String playerName = player.getName();
		dataKey = dataKey.toLowerCase();

		return playerData.containsKey(playerName) && playerData.get(playerName).get(dataKey) != null;
	}

	/*
	 * getPlayerData() : Returns (Object)dataValue for (int)playerID's (String)dataKey.
	 */
	public Object getPlayerData(OfflinePlayer player, String dataKey)
	{
		String playerName = player.getName();
		dataKey = dataKey.toLowerCase();

		if(playerData.containsKey(playerName))
		{
			if(playerData.get(playerName).get(dataKey) != null) return playerData.get(playerName).get(dataKey);
			else return null;
		}
		else return null;
	}

	/*
	 * ---------------------------------------------------
	 * Begin Warp Data Methods
	 * ---------------------------------------------------
	 * 
	 * saveWarpData() : Saves (String)dataKey to (int)playerID HashMap.
	 */
	public boolean saveWarpData(PlayerCharacter character, SerialLocation warp)
	{
		if(hasCharData(character.getID(), "warps"))
		{
			ArrayList<SerialLocation> warps = (ArrayList<SerialLocation>) getCharData(character.getID(), "warps");
			warps.add(warp);
			saveCharData(character.getID(), "warps", warps);
			return true;
		}
		else
		{
			ArrayList<SerialLocation> warps = new ArrayList<SerialLocation>();
			warps.add(warp);
			saveCharData(character.getID(), "warps", warps);
			return true;
		}
	}

	/*
	 * removeWarpData() : Removes (String)dataKey from (int)playerID's HashMap.
	 */
	public boolean removeWarpData(PlayerCharacter character, SerialLocation warp)
	{
		if(hasWarpData(character, warp))
		{
			ArrayList<SerialLocation> warps = (ArrayList<SerialLocation>) getCharData(character.getID(), "warps");
			warps.remove(warp);
			saveCharData(character.getID(), "warps", warps);
			return true;
		}
		else return false;
	}

	/*
	 * hasWarpData() : Returns true/false according to if (String)dataKey exists for (int)playerID.
	 */
	public boolean hasWarpData(PlayerCharacter character, SerialLocation warp)
	{
		return hasCharData(character.getID(), "warps") && ((ArrayList<SerialLocation>) getCharData(character.getID(), "warps")).contains(warp);
	}

	/*
	 * ---------------------------------------------------
	 * Begin PlayerCharacter Data Methods
	 * ---------------------------------------------------
	 * 
	 * charExists() : Returns true/false depening on if the character exists.
	 */
	public boolean charExists(String charName)
	{
		return charData.containsKey(charName);
	}

	/*
	 * charExistsByID() : Returns true/false depening on if the character exists.
	 */
	public boolean charExistsByID(int charID)
	{
		return charData.containsKey(charID);
	}

	/*
	 * addChar() : Saves the (int)charID to the charData HashMap.
	 */
	public boolean addChar(int charID)
	{
		charData.put(charID, new HashMap<String, Object>());
		return true;
	}

	/*
	 * removeChar() : Removes the (int)charID from the charData HashMap.
	 */
	public boolean removeChar(int charID)
	{
		charData.remove(charID);

		// TEMP -------------------------------
		// DDatabase.removeChar(charID);

		return true;
	}

	/*
	 * saveCharData() : Saves (String)dataKey to (int)charID HashMap.
	 */
	public boolean saveCharData(int charID, String dataKey, Object dataValue)
	{
		dataKey = dataKey.toLowerCase();

		if(charData.containsKey(charID))
		{
			charData.get(charID).put(dataKey, dataValue);
			return true;
		}
		else return false;
	}

	/*
	 * removeCharData() : Removes (String)dataKey from (int)charID's HashMap.
	 */
	public boolean removeCharData(int charID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		if(charData.containsKey(charID))
		{
			charData.get(charID).remove(dataKey);
			return true;
		}
		else return false;
	}

	/*
	 * hashCharData() : Returns true/false according to if (String)dataKey exists for (int)charID.
	 */
	public boolean hasCharData(int charID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		return charData.containsKey(charID) && charData.get(charID).get(dataKey) != null;
	}

	/*
	 * getCharData() : Returns (Object)dataValue for (int)charID's (String)dataKey.
	 */
	public Object getCharData(int charID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		if(charData.containsKey(charID))
		{
			if(charData.get(charID).get(dataKey) != null) return charData.get(charID).get(dataKey);
			else return null;
		}
		else return null;
	}

	/*
	 * ---------------------------------------------------
	 * Begin Battle Data Methods
	 * ---------------------------------------------------
	 * 
	 * battleExistsByID() : Returns true/false depening on if the battle exists.
	 */
	public boolean battleExistsByID(int battleID)
	{
		return battleData.containsKey(battleID);
	}

	/*
	 * addBattle() : Saves the (int)battleID to the battleData HashMap.
	 */
	public boolean addBattle(int battleID)
	{
		battleData.put(battleID, new HashMap<String, Object>());
		return true;
	}

	/*
	 * removeBattle() : Removes the (int)battleID from the battleData HashMap.
	 */
	public boolean removeBattle(int battleID)
	{
		battleData.remove(battleID);
		return true;
	}

	/*
	 * saveBattleData() : Saves (String)dataKey to (int)battleID HashMap.
	 */
	public boolean saveBattleData(int battleID, String dataKey, Object dataValue)
	{
		dataKey = dataKey.toLowerCase();

		if(battleData.containsKey(battleID))
		{
			battleData.get(battleID).put(dataKey, dataValue);
			return true;
		}
		else return false;
	}

	/*
	 * removeBattleData() : Removes (String)dataKey from (int)battleID's HashMap.
	 */
	public boolean removeBattleData(int battleID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		if(battleData.containsKey(battleID))
		{
			battleData.get(battleID).remove(dataKey);
			return true;
		}
		else return false;
	}

	/*
	 * hasBattleData() : Returns true/false according to if (String)dataKey exists for (int)battleID.
	 */
	public boolean hasBattleData(int battleID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		return battleData.containsKey(battleID) && battleData.get(battleID).get(dataKey) != null;
	}

	/*
	 * getBattleData() : Returns (Object)dataValue for (int)battleID's (String)dataKey.
	 */
	public Object getBattleData(int battleID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		if(battleData.containsKey(battleID))
		{
			if(battleData.get(battleID).get(dataKey) != null) return battleData.get(battleID).get(dataKey);
			else return null;
		}
		else return null;
	}

	/*
	 * ---------------------------------------------------
	 * Begin Task Data Methods
	 * ---------------------------------------------------
	 * 
	 * taskExistsByID() : Returns true/false depening on if the task exists.
	 */
	public boolean taskExistsByID(int taskID)
	{
		return taskData.containsKey(taskID);
	}

	/*
	 * addTask() : Saves the (int)taskID to the taskData HashMap.
	 */
	public boolean addTask(int taskID)
	{
		taskData.put(taskID, new HashMap<String, Object>());
		return true;
	}

	/*
	 * removeTask() : Removes the (int)taskID from the taskData HashMap.
	 */
	public boolean removeTask(int taskID)
	{
		taskData.remove(taskID);
		return true;
	}

	/*
	 * saveTaskData() : Saves (String)dataKey to (int)taskID HashMap.
	 */
	public boolean saveTaskData(int taskID, String dataKey, Object dataValue)
	{
		dataKey = dataKey.toLowerCase();

		if(taskData.containsKey(taskID))
		{
			taskData.get(taskID).put(dataKey, dataValue);
			return true;
		}
		else return false;
	}

	/*
	 * removeTaskData() : Removes (String)dataKey from (int)taskID's HashMap.
	 */
	public boolean removeTaskData(int taskID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		if(taskData.containsKey(taskID))
		{
			taskData.get(taskID).remove(dataKey);
			return true;
		}
		else return false;
	}

	/*
	 * hasTaskData() : Returns true/false according to if (String)dataKey exists for (int)taskID.
	 */
	public boolean hasTaskData(int taskID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		return taskData.containsKey(taskID) && taskData.get(taskID).get(dataKey) != null;
	}

	/*
	 * getTaskData() : Returns (Object)dataValue for (int)taskID's (String)dataKey.
	 */
	public Object getTaskData(int taskID, String dataKey)
	{
		dataKey = dataKey.toLowerCase();

		if(taskData.containsKey(taskID))
		{
			if(taskData.get(taskID).get(dataKey) != null) return taskData.get(taskID).get(dataKey);
			else return null;
		}
		else return null;
	}

	/*
	 * ---------------------------------------------------
	 * Begin Miscellaneous Data Methods
	 * ---------------------------------------------------
	 * 
	 * addPlayer() : Saves new (String)username to HashMap playerData.
	 */
	public boolean addPlayer(OfflinePlayer player, int playerID)
	{
		String playerName = player.getName();

		// Returns false if the player already has the playerData.
		if(newPlayer(player))
		{
			// Creates new player HashMap save.
			playerData.put(playerName, new HashMap<String, Object>());
			return true;
		}
		else return false;
	}

	/*
	 * newPlayer() : Checks to see if (String)username already has HashMap playerData.
	 */
	public boolean newPlayer(OfflinePlayer player)
	{
		String playerName = player.getName();

		return !playerData.containsKey(playerName);
	}

	/*
	 * removePlayer() : Removes the (OfflinePlayer)player from the playerData HashMap.
	 */
	public boolean removePlayer(OfflinePlayer player)
	{
		String playerName = player.getName();
		playerData.remove(playerName);
		charData.remove(playerName);

		return true;
	}

	/*
	 * getAllPlayers() : Returns all players in the playerData HashMap.
	 */
	public static HashMap<String, HashMap<String, Object>> getAllPlayers()
	{
		return playerData;
	}

	/*
	 * getAllPlayerData() : Returns all playerData for (Player)player.
	 */
	public static HashMap<String, Object> getAllPlayerData(OfflinePlayer player)
	{
		String playerName = player.getName();
		return playerData.get(playerName);
	}

	/*
	 * getAllChars() : Returns all players in the charData HashMap.
	 */
	public static HashMap<Integer, HashMap<String, Object>> getAllChars()
	{
		return charData;
	}

	/*
	 * getAllBattles() : Returns all battles in the battleData HashMap.
	 */
	public static HashMap<Integer, HashMap<String, Object>> getAllBattles()
	{
		return battleData;
	}

	/*
	 * getAllTasks() : Returns all battles in the battleData HashMap.
	 */
	public static HashMap<Integer, HashMap<String, Object>> getAllTasks()
	{
		return taskData;
	}

	/*
	 * getAllCharData() : Returns all charData for (int)charID.
	 */
	public static HashMap<String, Object> getAllCharData(int charID)
	{
		return charData.get(charID);
	}

	/*
	 * getAllPlayerChars() : Returns all charData for (int)charID.
	 */
	public HashMap<Integer, HashMap<String, Object>> getAllPlayerChars(OfflinePlayer player)
	{
		HashMap<Integer, HashMap<String, Object>> temp = new HashMap<Integer, HashMap<String, Object>>();
		int playerID = API.player.getPlayerID(player);

		for(Entry<Integer, HashMap<String, Object>> characters : getAllChars().entrySet())
		{
			int charID = characters.getKey();

			if(characters.getValue().get("char_owner") != null && characters.getValue().get("char_owner").equals(playerID))
			{
				temp.put(charID, characters.getValue());
			}
		}
		return temp;
	}

	/*
	 * ---------------------------------------------------
	 * Begin Timed Data Methods
	 * ---------------------------------------------------
	 * 
	 * cycleTimedData() : Cycles through all timed data and updates it accordingly.
	 */
	public void cycleTimedData()
	{
		for(Entry<Object, HashMap<String, HashMap<String, Object>>> data : timedData.entrySet())
		{
			for(Entry<String, HashMap<String, Object>> timed : data.getValue().entrySet())
			{
				if(API.object.toLong(timed.getValue().get("expires")) <= System.currentTimeMillis())
				{
					removeTimedData(data.getKey(), timed.getKey());
				}
			}
		}
	}

	/*
	 * saveTimedData() : Saves new timed data.
	 */
	public void saveTimedData(Object dataParent, String dataKey, Object dataValue, int seconds)
	{
		dataKey = dataKey.toLowerCase();

		if(!timedData.containsKey(dataParent))
		{
			timedData.put(dataParent, new HashMap<String, HashMap<String, Object>>());
			timedData.get(dataParent).put(dataKey, new HashMap<String, Object>());
		}
		timedData.get(dataParent).get(dataKey).put("expires", (System.currentTimeMillis() + (seconds * 1000)));
		timedData.get(dataParent).get(dataKey).put("value", dataValue);
	}

	/*
	 * removeTimedData() : Removed the timed data.
	 */
	public void removeTimedData(Object dataParent, String dataKey)
	{
		if(timedData.containsKey(dataParent) && timedData.get(dataParent).containsKey(dataKey)) timedData.get(dataParent).remove(dataKey);
		if(timedData.containsKey(dataParent) && timedData.get(dataParent).isEmpty()) timedData.remove(dataParent);
	}

	/*
	 * hasTimedData() : Returns true if the timed data exists.
	 */
	public boolean hasTimedData(Object dataParent, String dataKey)
	{
		return timedData.containsKey(dataParent) && timedData.get(dataParent).containsKey(dataKey);
	}
}
