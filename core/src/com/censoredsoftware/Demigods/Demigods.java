/*
	Copyright (c) 2013 The Demigods Team
	
	Demigods License v1
	
	This plugin is provided "as is" and without any warranty.  Any express or
	implied warranties, including, but not limited to, the implied warranties
	of merchantability and fitness for a particular purpose are disclaimed.
	In no event shall the authors be liable to any party for any direct,
	indirect, incidental, special, exemplary, or consequential damages arising
	in any way out of the use or misuse of this plugin.
	
	Definitions
	
	 1. This Plugin is defined as all of the files within any archive
	    file or any group of files released in conjunction by the Demigods Team,
	    the Demigods Team, or a derived or modified work based on such files.
	
	 2. A Modification, or a Mod, is defined as this Plugin or a derivative of
	    it with one or more Modification applied to it, or as any program that
	    depends on this Plugin.
	
	 3. Distribution is defined as allowing one or more other people to in
	    any way download or receive a copy of this Plugin, a Modified
	    Plugin, or a derivative of this Plugin.
	
	 4. The Software is defined as an installed copy of this Plugin, a
	    Modified Plugin, or a derivative of this Plugin.
	
	 5. The Demigods Team is defined as Alex Bennett and Alexander Chauncey
	    of http://www.censoredsoftware.com/.
	
	Agreement
	
	 1. Permission is hereby granted to use, copy, modify and/or
	    distribute this Plugin, provided that:
	
	    a. All copyright notices within source files and as generated by
	       the Software as output are retained, unchanged.
	
	    b. Any Distribution of this Plugin, whether as a Modified Plugin
	       or not, includes this license and is released under the terms
	       of this Agreement. This clause is not dependant upon any
	       measure of changes made to this Plugin.
	
	    c. This Plugin, Modified Plugins, and derivative works may not
	       be sold or released under any paid license without explicit 
	       permission from the Demigods Team. Copying fees for the 
	       transport of this Plugin, support fees for installation or
	       other services, and hosting fees for hosting the Software may,
	       however, be imposed.
	
	    d. Any Distribution of this Plugin, whether as a Modified
	       Plugin or not, requires express written consent from the
	       Demigods Team.
	
	 2. You may make Modifications to this Plugin or a derivative of it,
	    and distribute your Modifications in a form that is separate from
	    the Plugin. The following restrictions apply to this type of
	    Modification:
	
	    a. A Modification must not alter or remove any copyright notices
	       in the Software or Plugin, generated or otherwise.
	
	    b. When a Modification to the Plugin is released, a
	       non-exclusive royalty-free right is granted to the Demigods Team
	       to distribute the Modification in future versions of the
	       Plugin provided such versions remain available under the
	       terms of this Agreement in addition to any other license(s) of
	       the initial developer.
	
	    c. Any Distribution of a Modified Plugin or derivative requires
	       express written consent from the Demigods Team.
	
	 3. Permission is hereby also granted to distribute programs which
	    depend on this Plugin, provided that you do not distribute any
	    Modified Plugin without express written consent.
	
	 4. The Demigods Team reserves the right to change the terms of this
	    Agreement at any time, although those changes are not retroactive
	    to past releases, unless redefining the Demigods Team. Failure to
	    receive notification of a change does not make those changes invalid.
	    A current copy of this Agreement can be found included with the Plugin.
	
	 5. This Agreement will terminate automatically if you fail to comply
	    with the limitations described herein. Upon termination, you must
	    destroy all copies of this Plugin, the Software, and any
	    derivatives within 48 hours.
 */

package com.censoredsoftware.Demigods;

import java.net.URL;
import java.security.CodeSource;
import java.util.ArrayList;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import com.censoredsoftware.Demigods.Handlers.Abstract.DemigodsPlugin;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.event.HandlerList;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.java.JavaPlugin;

import com.censoredsoftware.Demigods.API.*;
import com.censoredsoftware.Demigods.Handlers.DCommandHandler;
import com.censoredsoftware.Demigods.Handlers.DMetricsEventCreator;
import com.censoredsoftware.Demigods.Handlers.DScheduler;
import com.censoredsoftware.Demigods.Handlers.Database.DFlatFile;
import com.censoredsoftware.Demigods.Libraries.Objects.DisconnectReasonFilter;
import com.censoredsoftware.Demigods.Listeners.*;
import com.massivecraft.factions.P;
import com.sk89q.worldguard.bukkit.WorldGuardPlugin;

public class Demigods extends JavaPlugin
{
	// This plugin
	public static Demigods INSTANCE = null;

	// Soft dependencies
	public static WorldGuardPlugin WORLDGUARD = null;
	public static P FACTIONS = null;

	// API
	public AbilityAPI ability = null;
	public AdminAPI admin = null;
	public BattleAPI battle = null;
	public BlockAPI block = null;
	public CharAPI character = null;
	public ConfigAPI config = null;
	public DataAPI data = null;
	public DeityAPI deity = null;
	public InstanceAPI instance = null;
	public InvAPI inventory = null;
	public ItemAPI item = null;
	public MiscAPI misc = null;
	public ObjAPI object = null;
	public PlayerAPI player = null;
	public PluginAPI plugin = null;
	public QuestAPI quest = null;
    public TaskAPI task = null;
	public UpdateAPI update = null;
	public ValueAPI value = null;
    public WarpAPI warp = null;
	public ZoneAPI zone = null;

	// Deity ClassPath List
	public final ArrayList<String> DEITYLIST = new ArrayList<String>();

	// Did dependencies load correctly?
	final boolean okayToLoad = true;

	@Override
	public void onEnable()
	{
		instance = new InstanceAPI(this);
		INSTANCE = instance.getInstance();
		ability = new AbilityAPI();
		admin = new AdminAPI();
		battle = new BattleAPI();
		block = new BlockAPI();
		character = new CharAPI();
		config = new ConfigAPI();
		data = new DataAPI();
		deity = new DeityAPI();
		inventory = new InvAPI();
		item = new ItemAPI();
		misc = new MiscAPI();
		object = new ObjAPI();
		player = new PlayerAPI();
		plugin = new PluginAPI();
        task = new TaskAPI();
		quest = new QuestAPI();
		update = new UpdateAPI();
		value = new ValueAPI();
        warp = new WarpAPI();
		zone = new ZoneAPI();

		// Initialize Configuration
		config.initializeConfig();

		loadDependencies();
		loadExpansions();

		if(okayToLoad)
		{
			loadDeities();

			// Data loading
			DFlatFile.load();

			DScheduler.startThreads();
			loadListeners();
			loadCommands();
            loadTasks();
			// checkUpdate();

			misc.getLog().setFilter(new DisconnectReasonFilter());

			misc.info("Enabled!");
		}
		else
		{
			misc.severe("Demigods cannot enable correctly because at least one required dependency was not found.");
			getPluginLoader().disablePlugin(getServer().getPluginManager().getPlugin("Demigods"));
		}
	}

	@Override
	public void onDisable()
	{
		if(okayToLoad)
		{
			// Uninitialize Plugin
			HandlerList.unregisterAll(this);
			DScheduler.stopThreads();
			DFlatFile.save();

			misc.info("Disabled!");
		}
	}

	/*
	 * loadTestCode() : Loads the code upon plugin enable.
	 */
	@SuppressWarnings("unused")
	private void loadTestCode()
	{
		// Don't remove the header and footer of the test code.
		misc.info("====== Begin Test Code =============================");

		// K, thanks
		misc.info("====== End Test Code ===============================");
	}

	/*
	 * loadListeners() : Loads all plugin listeners.
	 */
	private void loadListeners()
	{
		/* Debug Listener */
		getServer().getPluginManager().registerEvents(new DDebugListener(), this);
		/* Ability Listener */
		getServer().getPluginManager().registerEvents(new DAbilityListener(), this);
		/* General Player Listener */
		getServer().getPluginManager().registerEvents(new DPlayerListener(), this);
		/* General Entity Listener */
		getServer().getPluginManager().registerEvents(new DEntityListener(), this);
		/* Command Listener */
		getServer().getPluginManager().registerEvents(new DCommandListener(), this);
		/* Chunk Listener */
		getServer().getPluginManager().registerEvents(new DChunkListener(), this);
		/* Chat Listener */
		getServer().getPluginManager().registerEvents(new DChatListener(), this);
		/* Altar Listener */
		getServer().getPluginManager().registerEvents(new DAltarListener(), this);
		/* Shrine Listener */
		getServer().getPluginManager().registerEvents(new DShrineListener(), this);
		/* Character Listener */
		getServer().getPluginManager().registerEvents(new DCharacterListener(), this);
		/* Block Listener */
		getServer().getPluginManager().registerEvents(new DBlockListener(), this);
		/* Event Creator */
		getServer().getPluginManager().registerEvents(new DMetricsEventCreator(), this);
	}

	/*
	 * loadCommands() : Loads all plugin commands and sets their executors.
	 */
	private void loadCommands()
	{
		// Define Main CommandExecutor
		DCommandHandler ce = new DCommandHandler();

		// Define General Commands
		getCommand("dg").setExecutor(ce);
		getCommand("check").setExecutor(ce);
		getCommand("owner").setExecutor(ce);
		getCommand("removechar").setExecutor(ce);
		getCommand("test1").setExecutor(ce);
		getCommand("viewmaps").setExecutor(ce);
		getCommand("viewblocks").setExecutor(ce);
		getCommand("viewtasks").setExecutor(ce);
	}

	/*
	 * loadDeities() : Loads the deities.
	 */
	@SuppressWarnings("unchecked")
	public void loadDeities()
	{
		misc.info("Loading deities...");

		// Find all deities
		CodeSource demigodsSrc = Demigods.class.getProtectionDomain().getCodeSource();
		if(demigodsSrc != null)
		{
			try
			{
				URL demigodsJar = demigodsSrc.getLocation();
				ZipInputStream demigodsZip = new ZipInputStream(demigodsJar.openStream());

				ZipEntry demigodsFile;

				// Define variables
				long startTimer = System.currentTimeMillis();

				while((demigodsFile = demigodsZip.getNextEntry()) != null)
				{
					if(demigodsFile.getName().contains("$")) continue;
					String deityName = demigodsFile.getName().replace("/", ".").replace(".class", "").replaceAll("\\d*$", "");
					if(deityName.contains("_deity"))
					{
						DEITYLIST.add(deityName);
					}
				}

				for(String deityPath : DEITYLIST)
				{
					ClassLoader loader = deity.getClassLoader(deityPath);

					// Load everything else for the Deity (Listener, etc.)
					String message = (String) deity.invokeDeityMethod(deityPath, loader, "loadDeity");
					String name = (String) deity.invokeDeityMethod(deityPath, loader, "getName");
					String alliance = (String) deity.invokeDeityMethod(deityPath, loader, "getAlliance");

					ChatColor color = (ChatColor) deity.invokeDeityMethod(deityPath, loader, "getColor");
					ArrayList<String> commands = (ArrayList<String>) deity.invokeDeityMethod(deityPath, loader, "getCommands");
					ArrayList<Material> claimItems = (ArrayList<Material>) deity.invokeDeityMethod(deityPath, loader, "getClaimItems");

					// Add to HashMap
					data.savePluginData("temp_deity_classes", name, deityPath);
					data.savePluginData("temp_deity_alliances", name, alliance);
					data.savePluginData("temp_deity_colors", name, color);
					data.savePluginData("temp_deity_commands", name, commands);
					data.savePluginData("temp_deity_claim_items", name, claimItems);

					// Display the success message
					misc.info(message);
				}
				// Stop the timer
				long stopTimer = System.currentTimeMillis();
				double totalTime = (double) (stopTimer - startTimer);

				misc.info("All deities loaded in " + totalTime / 1000 + " seconds.");
			}
			catch(Exception e)
			{
				misc.severe("There was a problem while loading deities!");
				e.printStackTrace();
			}
		}
	}

	/*
	 * loadDependencies() : Loads all dependencies.
	 */
	public void loadDependencies()
	{
		// Check for the WorldGuard plugin (optional)
		Plugin pg = getServer().getPluginManager().getPlugin("WorldGuard");
		if((pg != null) && (pg instanceof WorldGuardPlugin))
		{
			WORLDGUARD = (WorldGuardPlugin) pg;
			if(config.getSettingBoolean("use_dynamic_pvp_zones") && !config.getSettingBoolean("allow_skills_everywhere"))
			{
				misc.warning("WorldGuard no-PVP Flags are not compatible with dynamic pvp zones.");
				misc.warning("Instead of using flags, please name all no-PVP zones 'REGION_nopvp'.");
				misc.warning("Players will be invincible in no-PVP zones.");
			}
			if(!config.getSettingBoolean("allow_skills_everywhere")) misc.info("WorldGuard detected. Certain skills are disabled in no-PvP zones.");
		}

		// Check for the Factions plugin (optional)
		pg = getServer().getPluginManager().getPlugin("Factions");
		if((pg != null) && (pg instanceof P))
		{
			FACTIONS = (P) pg;
			if(config.getSettingBoolean("use_dynamic_pvp_zones") && !config.getSettingBoolean("allow_skills_everywhere"))
			{
				misc.warning("Factions is not compatible with dynamic pvp zones!");
				misc.warning("Please either change the settings of Demigods, or remove Factions!");
			}
			else if(!config.getSettingBoolean("allow_skills_everywhere")) misc.info("Factions detected. Certain skills are disabled in safe zones zones.");
		}
	}

	/*
	 * loadExpansions() : Loads all expansions.
	 */
	public void loadExpansions()
	{
		// Check for expansions
		for(Plugin expansion : getServer().getPluginManager().getPlugins())
		{
			if(expansion instanceof DemigodsPlugin)
			{
				DemigodsPlugin EXPANSION = (DemigodsPlugin) expansion;
				EXPANSION.loadAPI();
				for(String deityPath : EXPANSION.getDeityPaths())
				{
					if(!DEITYLIST.contains(deityPath))
					{
						DEITYLIST.add(deityPath);

						data.savePluginData("temp_deity_classloader", deityPath, EXPANSION.getClass().getClassLoader()); // TODO OLD (Convert Deities First)
					}
				}
			}
		}
	}

    public void loadTasks()
    {
        Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(INSTANCE, new Runnable()
        {
            @Override
            public void run()
            {
                try
                {
                    task.invokeAllTasks();
                    misc.info("Tasks have finished loading!");
                }
                catch (Exception e)
                {
                    misc.severe("There was an error while loading tasks.");
                    e.printStackTrace();
                }
            }
        }, 30);
    }

	@SuppressWarnings("unused")
	private void checkUpdate()
	{
		// Check for updates, and then update if need be
		if(update.shouldUpdate() && config.getSettingBoolean("auto_update")) update.demigodsUpdate();
	}
}
